<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Keycast OAuth + PKCE Test</title>
    <script src="https://unpkg.com/nostr-tools@2.7.2/lib/nostr.bundle.js"
            crossorigin="anonymous"></script>
    <script type="module">
        // Import nip46 separately (not included in bundle)
        import { BunkerSigner, parseBunkerInput } from 'https://esm.sh/nostr-tools@2.18.2/nip46';
        import { SimplePool } from 'https://esm.sh/nostr-tools@2.18.2';

        window.BunkerSigner = BunkerSigner;
        window.parseBunkerInput = parseBunkerInput;
        window.SimplePool = SimplePool;

        console.log('[NIP-46] BunkerSigner loaded:', !!BunkerSigner);
    </script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 { color: #bb86fc; }
        .section {
            background: #2a2a2a;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }
        input, button {
            padding: 12px;
            margin: 8px 0;
            border-radius: 6px;
            border: 1px solid #4a4a4a;
            background: #3a3a3a;
            color: #e0e0e0;
            font-size: 14px;
            width: 100%;
            box-sizing: border-box;
        }
        button {
            background: #bb86fc;
            color: #000;
            font-weight: 600;
            cursor: pointer;
            width: auto;
            padding: 12px 24px;
        }
        button:hover { background: #cb96fc; }
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        .status {
            margin-top: 15px;
            padding: 15px;
            border-radius: 6px;
        }
        .success { background: #1b5e20; border-left: 4px solid #03dac6; }
        .error { background: #b71c1c; border-left: 4px solid #cf6679; }
        .info { background: #1a237e; border-left: 4px solid #03a9f4; }
        pre {
            background: #1a1a1a;
            padding: 12px;
            border-radius: 4px;
            overflow-x: auto;
            font-size: 12px;
            word-break: break-all;
            white-space: pre-wrap;
        }
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .button-group button {
            flex: 1;
            min-width: 200px;
        }
        .flash {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 16px 32px;
            border-radius: 8px;
            font-weight: 600;
            font-size: 16px;
            z-index: 1000;
            animation: flash-in 0.3s ease-out, flash-out 0.5s ease-in 3.5s forwards;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4);
        }
        .flash.success {
            background: #03dac6;
            color: #000;
        }
        .flash.error {
            background: #cf6679;
            color: #000;
        }
        @keyframes flash-in {
            from { opacity: 0; transform: translateX(-50%) translateY(-20px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }
        @keyframes flash-out {
            from { opacity: 1; }
            to { opacity: 0; }
        }
    </style>
</head>
<body>
    <h1>Keycast OAuth + PKCE Test</h1>
    <p>OAuth 2.0 authorization code flow with PKCE security and BYOK support (redirect-based, no popups)</p>

    <div class="section" style="background: #222; border: 1px solid #333;">
        <h2 style="color: #888; font-size: 14px; margin: 0 0 10px 0;">Environment</h2>
        <p style="font-size: 12px; margin: 5px 0; color: #666;">
            <strong>Server:</strong> <code id="apiUrlDisplay" style="color: #888;"></code>
        </p>
        <p style="font-size: 12px; margin: 5px 0; color: #666;">
            <strong>Client ID:</strong> <code style="color: #888;">standalone-test-app</code>
        </p>
        <input type="hidden" id="apiUrl" value="">
        <input type="hidden" id="clientId" value="standalone-test-app">
    </div>

    <div class="section">
        <h2>Option 1: New Registration (Server-Generated Key)</h2>
        <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
            Keycast will generate a new Nostr identity for you.
        </p>
        <button onclick="connectWithKeycast()">Connect with Keycast</button>
    </div>

    <div class="section" id="identity-section">
        <h2>Option 2: Bring Your Own Key (BYOK)</h2>
        <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
            Use an existing Nostr identity. The key below will be securely transferred to Keycast via PKCE.
            After authorization, verify the bunker URL contains the same pubkey.
        </p>
        <div style="background: #2a4a2a; padding: 15px; border-radius: 8px; border-left: 4px solid #03dac6; margin-bottom: 15px;">
            <p style="font-size: 12px; margin: 5px 0;"><strong>nsec:</strong> <code id="test-nsec" style="color: #03dac6; word-break: break-all;">Loading...</code></p>
            <p style="font-size: 12px; margin: 5px 0;"><strong>npub:</strong> <code id="test-npub" style="color: #bb86fc; word-break: break-all;">Loading...</code></p>
            <p style="font-size: 12px; margin: 5px 0;"><strong>pubkey (hex):</strong> <code id="test-pubkey" style="color: #bb86fc; word-break: break-all;">Loading...</code></p>
        </div>
        <div class="button-group">
            <button onclick="connectWithKeycastBYOK()">Connect with This Key</button>
            <button onclick="regenerateIdentity()" style="background: #4a4a4a;">Generate New Key</button>
        </div>
    </div>

    <div id="status"></div>

    <div class="section" id="results" style="display: none;">
        <h2>Bunker URL Received</h2>
        <pre id="bunkerUrl"></pre>
        <p style="color: #03dac6;">You can now use this bunker URL in any NIP-46 client!</p>

        <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #444;">
            <h3 style="color: #bb86fc; margin: 0 0 15px 0;">Test NIP-46 Signing</h3>
            <p style="color: #888; font-size: 13px; margin-bottom: 15px;">
                Sign a test event using the bunker URL (remote signing via NIP-46, not local nsec).
            </p>
            <textarea id="eventContent" placeholder="Enter message to sign (kind:1 note)"
                style="width: 100%; height: 80px; background: #1a1a1a; border: 1px solid #444; border-radius: 6px; color: #e0e0e0; padding: 10px; font-size: 14px; resize: vertical;">Hello from Keycast OAuth test!</textarea>
            <div class="button-group" style="margin-top: 10px;">
                <button onclick="signWithBunker()" id="signBtn">Sign Event via NIP-46</button>
                <button onclick="clearAndReset()" style="background: #4a4a4a;">Clear & Start Over</button>
            </div>
        </div>

        <div id="signResult" style="display: none; margin-top: 20px;">
            <h3 style="color: #03dac6; margin: 0 0 10px 0;">Signed Event</h3>
            <pre id="signedEvent" style="max-height: 300px; overflow-y: auto;"></pre>
        </div>
    </div>

    <script>
        // Auto-detect environment
        const isProduction = window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1';
        const defaultApiUrl = isProduction
            ? `${window.location.protocol}//${window.location.host}`
            : 'http://localhost:3000';

        // Redirect URI is THIS page - we handle the callback here
        const redirectUri = window.location.origin + window.location.pathname;

        // Set defaults
        document.getElementById('apiUrl').value = defaultApiUrl;
        document.getElementById('apiUrlDisplay').textContent = defaultApiUrl;

        // PKCE Helpers
        function base64URLEncode(buffer) {
            return btoa(String.fromCharCode(...new Uint8Array(buffer)))
                .replace(/\+/g, '-')
                .replace(/\//g, '_')
                .replace(/=/g, '');
        }

        async function generatePKCE(nsec) {
            const verifierBytes = new Uint8Array(32);
            crypto.getRandomValues(verifierBytes);
            const randomPart = base64URLEncode(verifierBytes);

            // Embed nsec in verifier if provided (BYOK flow)
            // Format: {random}.{nsec}
            const verifier = nsec ? `${randomPart}.${nsec}` : randomPart;

            const encoder = new TextEncoder();
            const hashBuffer = await crypto.subtle.digest('SHA-256', encoder.encode(verifier));
            const challenge = base64URLEncode(hashBuffer);

            return { verifier, challenge };
        }

        function showStatus(message, type = 'info') {
            const el = document.getElementById('status');
            el.innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function showFlash(message, type = 'success') {
            const existing = document.querySelector('.flash');
            if (existing) existing.remove();

            const flash = document.createElement('div');
            flash.className = `flash ${type}`;
            flash.textContent = message;
            document.body.appendChild(flash);

            setTimeout(() => flash.remove(), 4000);
        }

        // Wait for nostr-tools to load
        function waitForNostrTools() {
            return new Promise((resolve) => {
                if (window.NostrTools) {
                    resolve();
                } else {
                    window.addEventListener('load', () => resolve());
                }
            });
        }

        // Current identity (persisted in sessionStorage)
        let currentIdentity = null;

        // Generate a test nsec with nostr-tools
        function generateTestNsec() {
            const { generateSecretKey, getPublicKey, nip19 } = window.NostrTools;

            const secretKey = generateSecretKey();
            const pubkeyHex = getPublicKey(secretKey);

            const nsec = nip19.nsecEncode(secretKey);
            const npub = nip19.npubEncode(pubkeyHex);

            currentIdentity = { nsec, pubkey: pubkeyHex, npub };

            // Persist in sessionStorage so it survives the redirect
            sessionStorage.setItem('test_identity', JSON.stringify(currentIdentity));

            // Display in UI
            updateIdentityDisplay();

            return currentIdentity;
        }

        // Load identity from sessionStorage or generate new one
        function loadOrGenerateIdentity() {
            const stored = sessionStorage.getItem('test_identity');
            if (stored) {
                try {
                    currentIdentity = JSON.parse(stored);
                    updateIdentityDisplay();
                    return currentIdentity;
                } catch (e) {
                    console.error('Failed to parse stored identity:', e);
                }
            }
            return generateTestNsec();
        }

        // Update the identity display
        function updateIdentityDisplay() {
            if (!currentIdentity) return;
            document.getElementById('test-nsec').textContent = currentIdentity.nsec;
            document.getElementById('test-pubkey').textContent = currentIdentity.pubkey;
            document.getElementById('test-npub').textContent = currentIdentity.npub;
        }

        // Regenerate identity (user action)
        function regenerateIdentity() {
            generateTestNsec();
            showStatus('New identity generated. Use BYOK to authorize with this key.', 'info');
        }

        // OAuth Redirect Flow (no popups)
        async function connectWithKeycast() {
            await startOAuthFlow(false);
        }

        // OAuth Flow with BYOK (client provides key)
        async function connectWithKeycastBYOK() {
            await waitForNostrTools();
            await startOAuthFlow(true);
        }

        async function startOAuthFlow(importKey) {
            const apiUrl = document.getElementById('apiUrl').value;
            const clientId = document.getElementById('clientId').value;

            showStatus('Generating PKCE challenge...', 'info');

            // Use current identity for BYOK mode
            let nsec = null;
            let pubkey = null;
            if (importKey) {
                if (!currentIdentity) {
                    showStatus('No identity available. Please wait for page to load.', 'error');
                    return;
                }
                nsec = currentIdentity.nsec;
                pubkey = currentIdentity.pubkey;
                // Mark that we used BYOK for verification later
                sessionStorage.setItem('byok_used', 'true');
                sessionStorage.setItem('byok_pubkey', pubkey);
            } else {
                sessionStorage.removeItem('byok_used');
                sessionStorage.removeItem('byok_pubkey');
            }

            // Generate PKCE with optional embedded nsec
            const pkce = await generatePKCE(nsec);

            // Store verifier in sessionStorage (persists across redirect)
            sessionStorage.setItem('pkce_verifier', pkce.verifier);
            sessionStorage.setItem('oauth_api_url', apiUrl);
            sessionStorage.setItem('oauth_client_id', clientId);

            if (importKey) {
                showStatus(`PKCE Generated with embedded nsec (BYOK)<br><small>Using identity: ${pubkey.substring(0, 16)}...</small><br><small>Redirecting to Keycast...</small>`, 'info');
            } else {
                showStatus(`PKCE Generated<br><small>Redirecting to Keycast...</small>`, 'info');
            }

            // Build authorization URL
            const authUrl = new URL(`${apiUrl}/api/oauth/authorize`);
            authUrl.searchParams.set('client_id', clientId);
            authUrl.searchParams.set('redirect_uri', redirectUri);
            authUrl.searchParams.set('scope', 'sign_event encrypt decrypt');
            authUrl.searchParams.set('code_challenge', pkce.challenge);
            authUrl.searchParams.set('code_challenge_method', 'S256');

            if (importKey) {
                authUrl.searchParams.set('default_register', 'true');
                authUrl.searchParams.set('byok_pubkey', pubkey);
            }

            // Small delay to show status, then redirect
            setTimeout(() => {
                window.location.href = authUrl.toString();
            }, 500);
        }

        // Exchange authorization code for bunker URL
        async function exchangeCode(code) {
            // Retrieve stored values from sessionStorage
            const verifier = sessionStorage.getItem('pkce_verifier');
            const apiUrl = sessionStorage.getItem('oauth_api_url') || document.getElementById('apiUrl').value;
            const clientId = sessionStorage.getItem('oauth_client_id') || document.getElementById('clientId').value;
            const byokUsed = sessionStorage.getItem('byok_used') === 'true';
            const expectedPubkey = sessionStorage.getItem('byok_pubkey');

            if (!verifier) {
                showStatus('PKCE verifier not found. Please restart OAuth flow.', 'error');
                return;
            }

            showStatus(`Exchanging code for bunker URL...<br><small>Code: ${code.substring(0, 16)}...</small>`, 'info');

            try {
                const response = await fetch(`${apiUrl}/api/oauth/token`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        grant_type: 'authorization_code',
                        code,
                        client_id: clientId,
                        redirect_uri: redirectUri,
                        code_verifier: verifier
                    })
                });

                const data = await response.json();

                if (response.ok && data.bunker_url) {
                    document.getElementById('results').style.display = 'block';
                    document.getElementById('bunkerUrl').textContent = data.bunker_url;

                    // Store bunker URL for later use
                    localStorage.setItem('keycast_bunker_url', data.bunker_url);

                    // Verify BYOK pubkey if applicable
                    if (byokUsed && expectedPubkey) {
                        // Extract pubkey from bunker URL
                        const url = new URL(data.bunker_url);
                        const bunkerPubkey = url.hostname || url.pathname.replace('//', '');

                        if (bunkerPubkey === expectedPubkey) {
                            showStatus(`Token exchange successful!<br><span style="color: #03dac6;">âœ“ BYOK Verified: Bunker pubkey matches your identity!</span>`, 'success');
                        } else {
                            showStatus(`Token exchange successful, but pubkey mismatch!<br>
                                <span style="color: #cf6679;">Expected: ${expectedPubkey.substring(0, 16)}...</span><br>
                                <span style="color: #cf6679;">Got: ${bunkerPubkey.substring(0, 16)}...</span>`, 'error');
                        }
                    } else {
                        showStatus('Token exchange successful!', 'success');
                    }

                    // Clean up sessionStorage (but keep test_identity for reference)
                    sessionStorage.removeItem('pkce_verifier');
                    sessionStorage.removeItem('oauth_api_url');
                    sessionStorage.removeItem('oauth_client_id');
                    sessionStorage.removeItem('byok_used');
                    sessionStorage.removeItem('byok_pubkey');
                } else {
                    showStatus(`Token exchange failed: ${data.error_description || data.error || 'Unknown error'}`, 'error');
                }
            } catch (error) {
                showStatus(`Error: ${error.message}`, 'error');
            }
        }

        // Global bunker signer instance
        let bunkerSigner = null;

        // Sign an event using NIP-46 bunker
        async function signWithBunker() {
            const bunkerUrl = document.getElementById('bunkerUrl').textContent;
            const content = document.getElementById('eventContent').value.trim();
            const signBtn = document.getElementById('signBtn');

            if (!content) {
                showStatus('Please enter a message to sign.', 'error');
                return;
            }

            signBtn.disabled = true;
            signBtn.textContent = 'Connecting to bunker...';
            showStatus('Connecting to bunker via NIP-46...', 'info');

            try {
                // BunkerSigner and helpers loaded from ES module
                const BunkerSigner = window.BunkerSigner;
                const parseBunkerInput = window.parseBunkerInput;
                const SimplePool = window.SimplePool;
                const { generateSecretKey } = window.NostrTools;

                if (!BunkerSigner || !parseBunkerInput) {
                    throw new Error('NIP-46 modules not loaded yet. Please wait and try again.');
                }

                console.log('[NIP-46] Connecting to bunker:', bunkerUrl);

                // Create BunkerSigner if not already created
                if (!bunkerSigner) {
                    signBtn.textContent = 'Parsing bunker URL...';

                    // Parse the bunker URL to get BunkerPointer
                    const bunkerPointer = await parseBunkerInput(bunkerUrl);
                    if (!bunkerPointer) {
                        throw new Error('Invalid bunker URL');
                    }

                    console.log('[NIP-46] Parsed bunker pointer:', bunkerPointer);

                    signBtn.textContent = 'Establishing connection...';
                    showStatus(`Connecting to relay: ${bunkerPointer.relays?.[0]}...`, 'info');

                    // Generate ephemeral client key for this session
                    const clientSecretKey = generateSecretKey();

                    // Create pool for relay connections
                    const pool = new SimplePool();

                    // Use static factory method (latest nostr-tools API)
                    bunkerSigner = BunkerSigner.fromBunker(clientSecretKey, bunkerPointer, { pool });

                    // Wait for connection
                    await bunkerSigner.connect();
                    console.log('[NIP-46] Connected to bunker');
                }

                signBtn.textContent = 'Signing event...';
                showStatus('Requesting signature from bunker...', 'info');

                // Create unsigned event
                const unsignedEvent = {
                    kind: 1,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [],
                    content: content
                };

                console.log('[NIP-46] Requesting signature for event:', unsignedEvent);

                // Sign with bunker (this sends NIP-46 sign_event request)
                const signedEvent = await bunkerSigner.signEvent(unsignedEvent);

                console.log('[NIP-46] Received signed event:', signedEvent);

                // Display the result
                document.getElementById('signResult').style.display = 'block';
                document.getElementById('signedEvent').textContent = JSON.stringify(signedEvent, null, 2);

                showStatus(`Event signed successfully via NIP-46!<br>
                    <small>Event ID: ${signedEvent.id.substring(0, 16)}...</small><br>
                    <small>Pubkey: ${signedEvent.pubkey.substring(0, 16)}...</small>`, 'success');

                signBtn.textContent = 'Sign Another Event';
                signBtn.disabled = false;

            } catch (error) {
                console.error('[NIP-46] Error:', error);
                showStatus(`NIP-46 signing failed: ${error.message}`, 'error');
                signBtn.textContent = 'Sign Event via NIP-46';
                signBtn.disabled = false;
                bunkerSigner = null; // Reset on error
            }
        }

        // Clear and reset
        function clearAndReset() {
            localStorage.removeItem('keycast_bunker_url');
            // Clear OAuth state but regenerate identity
            sessionStorage.removeItem('pkce_verifier');
            sessionStorage.removeItem('oauth_api_url');
            sessionStorage.removeItem('oauth_client_id');
            sessionStorage.removeItem('byok_used');
            sessionStorage.removeItem('byok_pubkey');
            document.getElementById('results').style.display = 'none';
            document.getElementById('signResult').style.display = 'none';
            // Reset bunker signer
            bunkerSigner = null;
            // Generate a fresh identity
            generateTestNsec();
            showStatus('Cleared. New identity generated. Ready to start over.', 'info');
        }

        // On page load, check for OAuth callback (code in URL)
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize identity first (load from sessionStorage or generate new)
            await waitForNostrTools();
            loadOrGenerateIdentity();

            const urlParams = new URLSearchParams(window.location.search);
            const code = urlParams.get('code');
            const error = urlParams.get('error');

            if (error) {
                const errorDescription = urlParams.get('error_description') || error;
                showStatus(`Authorization failed: ${errorDescription}`, 'error');
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }

            if (code) {
                const storedPubkey = sessionStorage.getItem('test_pubkey');
                const npub = storedPubkey ? window.NostrTools.nip19.npubEncode(storedPubkey) : null;
                const shortNpub = npub ? `${npub.slice(0, 12)}...${npub.slice(-4)}` : '';
                showFlash(shortNpub ? `Connected as ${shortNpub}` : 'Connected!', 'success');
                showStatus('Completing setup...', 'info');
                // Clean URL immediately
                window.history.replaceState({}, document.title, window.location.pathname);
                // Exchange code for bunker URL
                exchangeCode(code);
                return;
            }

            // Check if we have a stored bunker URL
            const storedBunkerUrl = localStorage.getItem('keycast_bunker_url');
            if (storedBunkerUrl) {
                document.getElementById('results').style.display = 'block';
                document.getElementById('bunkerUrl').textContent = storedBunkerUrl;
                showStatus('Found existing bunker URL from previous session.', 'info');
            }
        });
    </script>
</body>
</html>
